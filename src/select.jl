"""
    ModelSelection

Supertype for all methods used for generating alternative models.
"""
abstract type ModelSelection end

@fieldequal ModelSelection

show(io::IO, s::ModelSelection) = print(io, typeof(s).name.name)

"""
    GridSearch{TF<:AbstractFloat} <: ModelSelection

Exhaustively assess all parameters on a specified grid. See also [`grid`](@ref).
"""
struct GridSearch{TF<:AbstractFloat} <: ModelSelection
    v::Vector{TF}
    function GridSearch(v::Vector)
        eltype(v) <: AbstractFloat || (v = convert(Vector{Float64}, v))
        TF = eltype(v)
        any(v.<zero(TF)) && throw(ArgumentError("only nonnegative values are accepted"))
        return new{TF}(v)
    end
end

"""
    grid([v])

Specify the grid vector `v` used for [`GridSearch`](@ref).
If `v` is not provided, a default grid is used.
"""
grid(v::Vector) = GridSearch(v)
grid(v) = GridSearch([v...])
grid() = GridSearch(exp.(LinRange(-6, 6, 50)))

function show(io::IO, ::MIME"text/plain", s::GridSearch{TF}) where TF
    N = length(s.v)
    print(io, typeof(s).name.name, '{', TF, '}')
    println(io, " across ", N, " candidate value", N>1 ? "s:" : ":")
    print(IOContext(io, :compact=>true), "  ", s.v)
end

"""
    OptimSearch <: ModelSelection

Search the optimal regularization parameter with a user-specified function.
See also [`optim`](@ref).
"""
struct OptimSearch <: ModelSelection
    f::Function
end

"""
    optim(f::Function)

Specify the function used for searching the optimal regularization parameter.
See also [`OptimSearch`](@ref).

Function `f` accepts a univariate objective function associated with
the minimization problem to be solved and returns a tuple of two objects,
the solver result and the minimizer to the problem.
The objective function will be generated by [`convexfit`](@ref)
and passed to `f` for selecting the optimal regularization parameter.
"""
optim(f::Function) = OptimSearch(f)

function show(io::IO, ::MIME"text/plain", s::OptimSearch)
    print(io, typeof(s).name.name, ":\n  ")
    show(io, MIME("text/plain"), s.f)
end

"""
    ModelSelectionResult

Supertype for all results from model selection.
"""
abstract type ModelSelectionResult end

show(io::IO, sr::ModelSelectionResult) = print(io, typeof(sr).name.name)

"""
    GridSearchResult{TF<:AbstractFloat} <: ModelSelectionResult

Results from [`GridSearch`](@ref),
including estimates calculated for each parameter on the grid.

# Fields
- `iopt::Int`: index of the optimal parameter.
- `loocv::Vector{TF}`: leave-one-out cross validation errors.
"""
struct GridSearchResult{TF<:AbstractFloat} <: ModelSelectionResult
    iopt::Int
    loocv::Vector{TF}
end

function show(io::IO, ::MIME"text/plain", sr::GridSearchResult)
    N = length(sr.loocv)
    print(io, typeof(sr).name.name, " across ", N, " candidate value", N>1 ? "s:" : ":")
    print(io, " ", sr.iopt)
end

function loocv(A::Matrix{TF}, b::Vector{TF}, λ::Real; looargs...) where TF<:AbstractFloat
    M = size(A, 1)
    looca = get(looargs, :loocache, nothing)
    looca === nothing && (looca = Cache(view(A,2:M,:)))
    loocv = 0.0
    for m in 1:M
        ir = (1:M).!=m
        loos = convexfit(view(A,ir,:), view(b,ir), λ; cache=looca, looargs...)
        loofit = dot(view(A,m,:), loos.sol)
        loocv += (b[m] - loofit)^2
    end
    return loocv
end

function convexfit(A::Matrix{TF}, b::Vector{TF}, λs::GridSearch;
        looargs::Union{NamedTuple,Dict}=(show_trace=false, store_trace=false),
        kwargs...) where TF<:AbstractFloat
    K = length(λs.v)
    M = size(A, 1)
    M > 1 || throw(ArgumentError(
        "matrix A must contain at least two rows for model selection"))
    loocvs = Vector{Float64}(undef, K)
    for k in 1:K
        λ = λs.v[k]
        loocvs[k] = loocv(A, b, λ; looargs...)
    end
    _, iopt = findmin(loocvs)
    sr = GridSearchResult(iopt, loocvs)
    r = convexfit(A, b, λs.v[iopt]; kwargs...)
    return r, sr
end

function convexfit(A::Matrix{TF}, b::Vector{TF}, λs::OptimSearch;
        looargs::Union{NamedTuple,Dict}=(show_trace=false, store_trace=false),
        kwargs...) where TF<:AbstractFloat
    M = size(A, 1)
    M > 1 || throw(ArgumentError(
        "matrix A must contain at least two rows for model selection"))
    loocvobj(λ::Real) = loocv(A, b, λ; looargs...)
    sr, λopt = λs.f(loocvobj)
    r = convexfit(A, b, λopt; kwargs...)
    return r, sr
end
